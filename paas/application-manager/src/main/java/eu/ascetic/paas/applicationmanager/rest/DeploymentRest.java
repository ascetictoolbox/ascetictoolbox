package eu.ascetic.paas.applicationmanager.rest;

import javax.ws.rs.Consumes;
import javax.ws.rs.DELETE;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;

import org.apache.log4j.Logger;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

/**
 * ASCETiC Application Manager REST API to perform actions over an deployment of an Application
 * @author David Garcia Perez - Atos
 *
 */
@Path("/")
@Component
@Scope("request")
public class DeploymentRest extends AbstractRest {
	private static Logger logger = Logger.getLogger(DeploymentRest.class);
	
	/**
	 * @param applicationId the id of the application for which we want to know the deployments
	 * @return a list of deployments for an application stored in the database fitting the respective query params.
	 */
	@GET
	@Path("/applications/{application_id}/deployments")
	@Produces(MediaType.APPLICATION_XML)
	public Response getDeployments(@PathParam("application_id") String applicationId) {
		logger.info("GET request to paht: /applications/" + applicationId + "/deployments");
		// TODO
		// TODO it is necessary to implement a lot of query params here
		// TODO 
		return buildResponse(Status.OK, "Method not implemented yet");
	}
	
	/**
	 * Creates a new deployment for an Application in the Application Manager
	 * The input for this REST service must be a parsaable OVF ASCETiC document (although we are using standard OVF)
	 * @param applicationId the id of the application for which we want to start a new deployment based in a new OVF file
	 * @return The deployment reference stored in the database with its assigned autogenerated id.
	 */
	@POST
	@Path("/applications/{application_id}/deployments")
	@Consumes(MediaType.APPLICATION_XML)
	@Produces(MediaType.APPLICATION_XML)
	public Response postDeployment(@PathParam("application_id") String applicationId) {
		logger.info("POST request to path: /applications/" + applicationId + "/deployments");
		// TODO
		// TODO we need to import the XML Beans of the OVF developed by DJango
		return buildResponse(Status.CREATED, "Method not implemented yet");
	}
	
	/**
	 * Returns the information of an specific deployment
	 * @param applicationId of the application in the database
	 * @return deploymentId of the Deployment for the previously specify application
	 * @return the stored deployment information 
	 */
	@GET
	@Path("/applications/{application_id}/deployments/{deployment_id}")
	@Produces(MediaType.APPLICATION_XML)
	public Response getDeployment(@PathParam("application_id") String applicationId, @PathParam("deployment_id") String deploymentId) {
		logger.info("GET request to path: /applications/" + applicationId + "/deployments/" + deploymentId);
		//TODO
		return buildResponse(Status.OK, "Method not implemented yet");
	}
	
	/**
	 * Returns the agreement information between PaaS and IaaS layer for that specific deployment
	 * @param applicationId of the application in the database
	 * @param deploymentId of the Deployment for the previously specify application
	 * @return the stored agreement in its actual state 
	 */
	@GET
	@Path("/applications/{application_id}/deployments/{deployment_id}/agreement")
	@Produces(MediaType.APPLICATION_XML)
	public Response getDeploymentAgreement(@PathParam("application_id") String applicationId, @PathParam("deployment_id") String deploymentId) {
		logger.info("GET request to path: /applications/" + applicationId + "/deployments/" + deploymentId + "/agreement");
		// TODO
		// TODO 
		return buildResponse(Status.OK, "Method not implemented yet");
	}
	
	/**
	 * Returns the original submitted OVF that created this deployment for this application
	 * @param applicationId of the application in the database
	 * @param deploymentId of the Deployment for the previously specify application
	 * @return the stored ovf 
	 */
	@GET
	@Path("/applications/{application_id}/deployments/{deployment_id}/ovf")
	@Produces(MediaType.APPLICATION_XML)
	public Response getApplicationOvf(@PathParam("application_id") String applicationId, @PathParam("deployment_id") String deploymentId) {
		logger.info("GET request to path: /applications/" + applicationId + "/deployments/" + deploymentId + "/ovf");
		// TODO
		// TODO we need to think a bit about how we are going to store the OVF in the database, 
		//      I have not made my mind about it yet
		return buildResponse(Status.OK, "Method not implemented yet");
	}
	
	/**
	 * Accepts or rejects and agreement between PaaS and IaaS
	 * @param applicationId of the application in the database
	 * @param deploymentId of the Deployment for the previously specify application
	 * @return the updated agreement information
	 */
	@PUT
	@Path("/applications/{application_id}/deployments/{deployment_id}/agreement")
	@Consumes(MediaType.APPLICATION_XML)
	@Produces(MediaType.APPLICATION_XML)
	public Response putDeploymentAgreement(@PathParam("application_id") String applicationId, @PathParam("deployment_id") String deploymentId) {
		logger.info("PUT request to path: /applications/" + applicationId + "/deployments/" + deploymentId + "/agreement");
		// TODO
		// TODO 
		return buildResponse(Status.ACCEPTED, "Method not implemented yet");
	}
	
	/**
	 * Puts an deployment to terminated state and deletes any resource that this application has been used in the IaaS layer
	 * @param applicationId of the application in the database
	 * @param deploymentId of the Deployment for the previously specify application
	 * @return ok if the termination process is possible
	 */
	@DELETE
	@Path("/applications/{id}/deployments/{deployment_id}")
	public Response deleteDeployment(@PathParam("application_id") String applicationId, @PathParam("deployment_id") String deploymentId) {
		logger.info("DELETE request to path: /applications/" + applicationId + "/deployments/" + deploymentId);
		// TODO
		// TODO this does not really deletes the deployment from the database, simply it puts
		//      the application in terminated state and deletes any resource associated to it
		return buildResponse(Status.ACCEPTED, "Method not implemented yet");
	}
}
