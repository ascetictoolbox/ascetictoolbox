/*
 *  Copyright 2002-2014 Barcelona Supercomputing Center (www.bsc.es)
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */



#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <ctype.h>
#include "backend.h"
#include "semantic.h"
#include "backendlib.h"

static FILE *stubsFile = NULL;
static FILE *workerFile = NULL;
static FILE *includeFile = NULL;

static FILE *const_file = NULL;
static char includeName[PATH_MAX];

static char *c_types[] = { "file", "int", "char", "char *", "unsigned char", "short", "int", "long",
"float", "double", "void *", "char", "char *", "long long", "void", "error"};

static char *c_out_types[] = {"file", "int", "char", "char *", "unsigned char", "short", "int", "long",
"float", "double", "void *", "char", "char *", "long long", "void", "error"};

void generate_prolog()
{
	char name[PATH_MAX];
	char *c;
	
	strncpy(name, get_filename_base(), PATH_MAX);
	strncat(name, "-stubs.cc", PATH_MAX);
	rename_if_clash(name);
	stubsFile = fopen(name, "w");
	if (stubsFile == NULL) {
		fprintf(stderr, "Error: Could not open %s for writing.\n", name);
		exit(1);
	}

	strncpy(name, get_filename_base(), PATH_MAX);
	strncat(name, "-worker.cc", PATH_MAX);
	rename_if_clash(name);
	workerFile = fopen(name, "w");
	if (workerFile == NULL) {
		fprintf(stderr, "Error: Could not open %s for writing.\n", name);
		exit(1);
	}

	strncpy(includeName, get_filename_base(), PATH_MAX);
	strncat(includeName, ".h", PATH_MAX);
	rename_if_clash(includeName);
	includeFile = fopen(includeName, "w");
	if (includeFile == NULL) {
		fprintf(stderr, "Error: Could not open %s for writing.\n", includeName);
		exit(1);
	}
	
	strncpy(name, get_filename_base(), PATH_MAX);
	strncat(name, "-constraints", PATH_MAX);
	rename_if_clash(name);
	const_file = fopen(name, "w");
	if (const_file == NULL) {
		fprintf(stderr, "Error: Could not open %s for writing.\n", name);
		exit(1);
	}
	
	fprintf(stubsFile, "/* This file has been autogenerated from '%s'. */\n", get_filename());
	fprintf(stubsFile, "/* CHANGES TO THIS FILE WILL BE LOST */\n");
	fprintf(stubsFile, "\n");
	fprintf(stubsFile, "#include <stdio.h>\n");
	fprintf(stubsFile, "#include <stdlib.h>\n");
	fprintf(stubsFile, "#include <limits.h>\n");
	fprintf(stubsFile, "#include <string.h>\n");
	fprintf(stubsFile, "#include <fstream>\n");
	fprintf(stubsFile, "#include <jni.h>\n");
	fprintf(stubsFile, "#include <boost/archive/text_iarchive.hpp>\n");
	fprintf(stubsFile, "#include <boost/archive/text_oarchive.hpp>\n");
	fprintf(stubsFile, "#include <GS_compss.h>\n");
	fprintf(stubsFile, "#include <param_metadata.h>\n");
	fprintf(stubsFile, "#include \"%s\"\n", includeName);

	fprintf(stubsFile, "\n");
	fprintf(stubsFile, "using namespace std;\n");
	fprintf(stubsFile, "using namespace boost;\n");

	fprintf(stubsFile, "\n");
	
	fprintf(workerFile, "/* This file has been autogenerated from '%s'. */\n", get_filename());
	fprintf(workerFile, "/* CHANGES TO THIS FILE WILL BE LOST */\n");
	fprintf(workerFile, "\n");
	fprintf(workerFile, "#include <stdio.h>\n");
	fprintf(workerFile, "#include <stdlib.h>\n");
	fprintf(workerFile, "#include <limits.h>\n");
	fprintf(workerFile, "#include <string.h>\n");
	fprintf(workerFile, "#include <fstream>\n");
	fprintf(workerFile, "#include <boost/archive/text_iarchive.hpp>\n");
	fprintf(workerFile, "#include <boost/archive/text_oarchive.hpp>\n");

	fprintf(workerFile, "#include \"%s\"\n", includeName);
	fprintf(workerFile, "\n");
	fprintf(workerFile, "using namespace std;\n");
	fprintf(workerFile, "\n");
	fprintf(workerFile, "int main(int argc, char **argv) {\n");
	fprintf(workerFile, "\n");
	fprintf(workerFile, "for(int i=0; i < argc; i++)\n");
	fprintf(workerFile, "\tprintf(\"%%s\\n\",argv[i]);\n");fprintf(workerFile, "\n");
	fprintf(workerFile, "\n");
	fprintf(workerFile, "enum operationCode opCod;\n");
	fprintf(workerFile, "char *opName;\n");
	fprintf(workerFile, "\n");
	fprintf(workerFile, "int arg_offset;\n");
	fprintf(workerFile, "arg_offset = 5;\n");
	fprintf(workerFile, "\n");
	fprintf(workerFile, "\n");
	fprintf(workerFile, "opName = strdup(argv[arg_offset]);\n");
	fprintf(workerFile, "arg_offset += 2;\n");
	fprintf(workerFile, "\n");
	fprintf(workerFile, "for(int i=0; i < N_OPS; i++)\n");
	fprintf(workerFile, "\tif(strcmp(operationName[i], opName) == 0)\n");
	fprintf(workerFile, "\t\topCod=(enum operationCode)i;\n");
	fprintf(workerFile, "\n");
	fprintf(workerFile, "switch(opCod)\n");
	fprintf(workerFile, "\t {\n");
	
	fprintf(includeFile, "/* This file must be #included in the actual implementation file. */\n");
	fprintf(includeFile, "/* This file has been autogenerated from '%s'. */\n", get_filename());
	fprintf(includeFile, "/* CHANGES TO THIS FILE WILL BE LOST */\n");
	fprintf(includeFile, "\n");
	fprintf(includeFile, "#ifndef _GSS_");
	for (c = includeName; *c; c++) {
		if (isalnum(*c)) {
			fprintf(includeFile, "%c", toupper(*c));
		} else {
			fprintf(includeFile, "_");
		}
	}
	fprintf(includeFile, "\n");

	fprintf(includeFile, "#define _GSS_");
	for (c = includeName; *c; c++) {
		if (isalnum(*c)) {
			fprintf(includeFile, "%c", toupper(*c));
		} else {
			fprintf(includeFile, "_");
		}
	}
	fprintf(includeFile, "\n");
	fprintf(includeFile, "#include <GS_compss.h>\n");
	fprintf(includeFile, "#include <GS_templates.h>\n");
	fprintf(includeFile, "#include <param_metadata.h>\n");
	fprintf(includeFile, "\n");
	fprintf(includeFile, "typedef char* file;\n");
	fprintf(includeFile, "\n");
}


void generate_epilogue(void)
{
	char *c;
	
	fprintf(workerFile, "   }\n");
	fprintf(workerFile, "\n");
	fprintf(workerFile, "   return 0;\n");
	fprintf(workerFile, "}\n");
	
	fprintf(includeFile, "\n");

	fprintf(includeFile, "#endif /* _GSS_");
	for (c = includeName; *c; c++) {
		if (isalnum(*c)) {
			fprintf(includeFile, "%c", toupper(*c));
		} else {
			fprintf(includeFile, "_");
		}
	}

	fprintf(includeFile, " */\n");

	fclose(stubsFile);
	fclose(workerFile);
	fclose(includeFile);
	fclose(const_file);

}

static void generate_constraints(function *func)
{
	constraint *constr;
	int is_first = 1;
	
	constr=func->first_constraint;
	while(constr!=NULL)
	{
		if(is_first)
			is_first = 0;
		else
			fprintf(const_file, ", ");
		
		fprintf(const_file, "%s", constr->name);
		constr = constr->next_constraint;
	}
	fprintf(const_file, "\n");

}

static void generate_enum(FILE *outFile, function *first_function)
{
	function *func;
	int is_first = 1;
	int n = 0;
	
	fprintf(outFile, "enum operationCode {");
	
	func = first_function;
	while (func != NULL) {
		if (is_first) {
			is_first = 0;
		} else {
			fprintf(outFile, ", ");
		}
		fprintf(outFile, "%sOp", func->name);
		n++;
		func = func->next_function;
	}
	
	fprintf(outFile, "};\n");
	
	is_first = 1;

	fprintf(outFile, "static const char *operationName[] = {");

	func = first_function;
	while (func != NULL) {
		if (is_first) {
			is_first = 0;
		} else {
			fprintf(outFile, ", ");
		}
		fprintf(outFile, "\"%s\"", func->name);
		func = func->next_function;
	}

	fprintf(outFile, "};\n");
	fprintf(outFile, "static const int N_OPS=%d;\n", n);
	fprintf(outFile ,"\n");
}


static void generate_prototype(FILE *outFile, function *current_function)
{
	argument *current_argument;

	fprintf(outFile, "%s %s(",
		c_types[current_function->return_type],
		current_function->name);
	current_argument = current_function->first_argument;
	while (current_argument != NULL) {
		if (current_argument->dir == in_dir) {
			switch (current_argument->type) {
				case char_dt:
				case wchar_dt:
				case boolean_dt:
				case short_dt:
				case long_dt:
				case longlong_dt:
				case int_dt:
				case float_dt:
				case double_dt:
					fprintf(outFile, "%s %s", c_out_types[current_argument->type], current_argument->name);
					break;
				case object_dt:
					fprintf(outFile, "%s %s", current_argument->classname, current_argument->name);
					break;
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "%s %s", c_out_types[current_argument->type], current_argument->name);
					break;
				case file_dt:
					fprintf(outFile, "%s %s", c_out_types[current_argument->type], current_argument->name);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:;
			}
		} else {
			switch (current_argument->type) {
				case char_dt:
				case wchar_dt:
				case boolean_dt:
				case short_dt:
				case long_dt:
				case longlong_dt:
				case int_dt:
				case float_dt:
				case double_dt:
					fprintf(outFile, "%s *%s", c_out_types[current_argument->type], current_argument->name);
					break;
				case object_dt:
					fprintf(outFile, "%s *%s", current_argument->classname, current_argument->name);
					break;
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "%s *%s", c_out_types[current_argument->type], current_argument->name);
					break;
				case file_dt:
					fprintf(outFile, "%s *%s", c_out_types[current_argument->type], current_argument->name);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:;
			}
		}
		current_argument = current_argument->next_argument;
		if (current_argument != NULL) {
			fprintf(outFile, ", ");
		}
	}
	fprintf(outFile, ")");
}


static void generate_class_includes(FILE *outFile, function *current_function)
{
	argument *current_argument;

	current_argument = current_function->first_argument;
	while (current_argument != NULL) {
		if (current_argument->type == object_dt) {
			fprintf(outFile, "#include \"%s.h\";\n", current_argument->classname);
		}
		current_argument = current_argument->next_argument;
	}
}

static void generate_parameter_buffers(FILE *outFile, function *func)
{
	fprintf(outFile, "\t void *arrayObjs[%d];\n", func->argument_count*3);
	fprintf(outFile, "\n");
}

static void generate_parameter_marshalling(FILE *outFile, function *func)
{
	argument *arg;
	int j = 0;
	int i = 0;

	arg = func->first_argument;
	while (arg != NULL) {
		i = j*3;

		if (arg->dir == out_dir || arg->dir == inout_dir) {

			switch (arg->type) {
				case char_dt:
				case wchar_dt:
				case boolean_dt:
				case short_dt:
				case long_dt:
				case longlong_dt:
				case int_dt:
				case float_dt:
				case double_dt:
				case object_dt:
					fprintf(outFile, "\t char *%s_filename = strdup(\"compss-serialized-obj_XXXXXX\");\n", arg->name);
					fprintf(outFile, "\t mkstemp(%s_filename);\n", arg->name);
					fprintf(outFile, "\t GS_register(%s, (datatype)%d, \"%s\", %s_filename);\n", arg->name, arg->type, arg->classname, arg->name);
					fprintf(outFile, "\t ofstream %s_ofs(%s_filename);\n", arg->name, arg->name);
					fprintf(outFile, "\t archive::text_oarchive %s_oa(%s_ofs);\n", arg->name, arg->name);
					fprintf(outFile, "\t %s_oa << *%s;\n", arg->name, arg->name);

					fprintf(outFile, "\t arrayObjs[%d] = &%s_filename;\n", i, arg->name);

					fprintf(outFile, "\t int param%d = %d;\n", i+1, file_dt);
					fprintf(outFile, "\t arrayObjs[%d] = &param%d;\n", i+1, i+1);

					fprintf(outFile, "\t int param%d = %d;\n", i+2, inout_dir);
					fprintf(outFile, "\t arrayObjs[%d] = &param%d;\n", i+2, i+2);
					break;
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "\t char *%s_filename = strdup(\"compss-serialized-obj_XXXXXX\");\n", arg->name);
					fprintf(outFile, "\t mkstemp(%s_filename);\n", arg->name);
					fprintf(outFile, "\t GS_register(%s, (datatype)%d, \"string\", %s_filename);\n", arg->name, arg->type, arg->name);
					fprintf(outFile, "\t ofstream %s_ofs(%s_filename);\n", arg->name, arg->name);
					fprintf(outFile, "\t archive::text_oarchive %s_oa(%s_ofs);\n", arg->name, arg->name);
					fprintf(outFile, "\t string %s_out_string (*%s);\n", arg->name, arg->name);
					fprintf(outFile, "\t %s_oa << %s_out_string;\n", arg->name, arg->name);

					fprintf(outFile, "\t arrayObjs[%d] = &%s_filename;\n", i, arg->name);

					fprintf(outFile, "\t int param%d = %d;\n", i+1, file_dt);
					fprintf(outFile, "\t arrayObjs[%d] = &param%d;\n", i+1, i+1);

					fprintf(outFile, "\t int param%d = %d;\n", i+2, inout_dir);
					fprintf(outFile, "\t arrayObjs[%d] = &param%d;\n", i+2, i+2);
					break;
				case file_dt:
					fprintf(outFile, "\t GS_register(%s, (datatype)%d, \"%s\", *%s);\n", arg->name, arg->type, arg->classname, arg->name);

					fprintf(outFile, "\t arrayObjs[%d] = %s;\n", i, arg->name);

					fprintf(outFile, "\t int param%d = %d;\n", i+1, arg->type);
					fprintf(outFile, "\t arrayObjs[%d] = &param%d;\n", i+1, i+1);

					fprintf(outFile, "\t int param%d = %d;\n", i+2, arg->dir);
					fprintf(outFile, "\t arrayObjs[%d] = &param%d;\n", i+2, i+2);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:;
			}
		} else {
			fprintf(outFile, "\t arrayObjs[%d] = &%s;\n", i, arg->name);

			fprintf(outFile, "\t int param%d = %d;\n", i+1, arg->type);
			fprintf(outFile, "\t arrayObjs[%d] = &param%d;\n", i+1, i+1);

			fprintf(outFile, "\t int param%d = %d;\n", i+2, arg->dir);
			fprintf(outFile, "\t arrayObjs[%d] = &param%d;\n", i+2, i+2);
		}

		fprintf(outFile, "\n");

		arg = arg->next_argument;
		j++;
	}
	
	fprintf(outFile, "\n");
}

static void generate_execute_call(FILE *outFile, function *func)
{
	char *appId = "0L";
	char *class_name = strdup("NULL");
	char *hasTarget = strdup("false");

	fprintf(outFile, "\t char *method_name = strdup(\"%s\");\n", func->name);

	fprintf(outFile, "\t GS_ExecuteTask(0L, \"%s\", method_name, 0, %s, %d, (void**)arrayObjs);\n", class_name, hasTarget, func->argument_count);

	fprintf(outFile, "\n");

	fprintf(outFile, "\t free(method_name);\n\n");
}

static void generate_worker_case(FILE *outFile, function *func)
{
	argument *arg;
	int j = 0;
	int i = 0;
	int is_first_arg = 1;
	
	fprintf(outFile, "\t case %sOp:\n", func->name);
	fprintf(outFile, "\t\t {\n");

	arg = func->first_argument;
	while (arg != NULL) {
		switch (arg->type) {
			case char_dt:
			case wchar_dt:
				fprintf(outFile, "\t\t\t char %s;\n", arg->name);
				break;
			case boolean_dt:
				fprintf(outFile, "\t\t\t int %s;\n", arg->name);
				break;
			case short_dt:
				fprintf(outFile, "\t\t\t short %s;\n", arg->name);
				break;
			case long_dt:
				fprintf(outFile, "\t\t\t long %s;\n", arg->name);
				break;
			case longlong_dt:
				fprintf(outFile, "\t\t\t long long %s;\n", arg->name);
                break;
			case int_dt:
				fprintf(outFile, "\t\t\t int %s;\n", arg->name);
				break;
			case float_dt:
				fprintf(outFile, "\t\t\t float %s;\n", arg->name);
				break;
			case double_dt:
				fprintf(outFile, "\t\t\t double %s;\n", arg->name);
				break;
			case file_dt:
				fprintf(outFile, "\t\t\t char *%s;\n", arg->name);
				break;
			case string_dt:
			case wstring_dt:
				fprintf(outFile, "\t\t\t char *%s;\n", arg->name);
				break;
			case object_dt:
				fprintf(outFile, "\t\t\t %s %s;\n", arg->classname, arg->name);
				break;
			case void_dt:
		case any_dt:
			case null_dt:
			default:
				;
		}
		arg = arg->next_argument;
	}
	fprintf(outFile, "\t\t\t \n");
	
	arg = func->first_argument;
	while (arg != NULL) {
		
		if (arg->dir == in_dir) {
			fprintf(outFile, "\t\t\t arg_offset += 2;\n");
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
					fprintf(outFile, "\t\t\t %s = argv[arg_offset][0];\n\n", arg->name);
					break;

				case boolean_dt:
					fprintf(outFile, "\t\t\t %s = argv[arg_offset]? 1 : 0;\n\n", arg->name);
					break;

				case short_dt:
                    fprintf(outFile, "\t\t\t %s = atoi(argv[arg_offset]);\n\n", arg->name);
					break;

				case long_dt:
                    fprintf(outFile, "\t\t\t %s = atol(argv[arg_offset]);\n\n", arg->name);
					break;
					
				case longlong_dt:
					fprintf(outFile, "\t\t\t %s = atoll(argv[arg_offset]);\n\n", arg->name);
					break;
					
				case int_dt:
					fprintf(outFile, "\t\t\t %s = atoi(argv[arg_offset]);\n\n", arg->name);
					break;

				case float_dt:
					fprintf(outFile, "\t\t\t %s = strtof(argv[arg_offset], NULL);\n\n", arg->name);
					break;
					
				case double_dt:
					fprintf(outFile, "\t\t\t %s = strtod(argv[arg_offset], NULL);\n\n", arg->name);
					break;

				case file_dt:
					fprintf(outFile, "\t\t\t %s = strdup(argv[arg_offset]);\n\n", arg->name);
					break;

				case string_dt:
				case wstring_dt:
					fprintf(outFile, "\t\t\t int %s_nwords = atoi(argv[arg_offset]);\n", arg->name);
					fprintf(outFile, "\t\t\t \n");
					fprintf(outFile, "\t\t\t int word_i;\n");
					fprintf(outFile, "\t\t\t int %s_size = 0;\n", arg->name);
					fprintf(outFile, "\t\t\t for (word_i=1; word_i<=%s_nwords; word_i++) {\n", arg->name);
					fprintf(outFile, "\t\t\t\t %s_size += strlen(argv[arg_offset + word_i]);\n", arg->name);
					fprintf(outFile, "\t\t\t }\n");
					fprintf(outFile, "\t\t\t %s = (char *) malloc(%s_size + %s_nwords);\n", arg->name,arg->name,arg->name);
					fprintf(outFile, "\t\t\t \n");
					fprintf(outFile, "\t\t\t for (word_i=1; word_i<=%s_nwords; word_i++) {\n", arg->name);
					fprintf(outFile, "\t\t\t\t arg_offset += 1;\n");
					fprintf(outFile, "\t\t\t\t if (word_i == 1)\n");
					fprintf(outFile, "\t\t\t\t\t strcat(%s, argv[arg_offset]);\n", arg->name);
					fprintf(outFile, "\t\t\t\t else {\n");
					fprintf(outFile, "\t\t\t\t\t strcat(%s, \" \");\n", arg->name);
					fprintf(outFile, "\t\t\t\t\t strcat(%s, argv[arg_offset]);\n", arg->name);
					fprintf(outFile, "\t\t\t\t }\n");
					fprintf(outFile, "\t\t\t }\n\n");
					break;

				case object_dt:

					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:;
			}
		}
		
		if (arg->dir == inout_dir) {
			fprintf(outFile, "\t\t\t arg_offset += 2;\n");
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
				case boolean_dt:
				case short_dt:
				case long_dt:
				case longlong_dt:
				case int_dt:
				case float_dt:
				case double_dt:
				case object_dt:
					fprintf(outFile, "\t\t\t char *%s_filename = strdup(argv[arg_offset]);\n", arg->name);
					fprintf(outFile, "\t\t\t ifstream %s_ifs(%s_filename, ios::binary);\n", arg->name, arg->name);
					fprintf(outFile, "\t\t\t archive::text_iarchive %s_ia(%s_ifs);\n", arg->name, arg->name);
					fprintf(outFile, "\t\t\t %s_ia >> %s;\n\n", arg->name, arg->name);
					break;
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "\t\t\t char *%s_filename = strdup(argv[arg_offset]);\n", arg->name);
					fprintf(outFile, "\t\t\t ifstream %s_ifs(%s_filename, ios::binary);\n", arg->name, arg->name);
					fprintf(outFile, "\t\t\t archive::text_iarchive %s_ia(%s_ifs);\n", arg->name, arg->name);
					fprintf(outFile, "\t\t\t string %s_in_string;\n", arg->name);
					fprintf(outFile, "\t\t\t %s_ia >> %s_in_string;\n", arg->name, arg->name);
					fprintf(outFile, "\t\t\t %s = strdup(%s_in_string.c_str());\n\n", arg->name, arg->name);
					break;
				case file_dt:
					fprintf(outFile, "\t\t\t %s = strdup(argv[arg_offset]);\n\n", arg->name);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:;
			}
		}

		arg = arg->next_argument;
	}

	fprintf(outFile, "\t\t\t %s(", func->name);
	is_first_arg = 1;
	arg = func->first_argument;
	while (arg != NULL) {
		if (is_first_arg) {
			is_first_arg = 0;
		} else {
			fprintf(outFile, ", ");
		}
		if (arg->dir == in_dir) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
				case boolean_dt:
				case short_dt:
				case long_dt:
				case longlong_dt:
				case int_dt:
				case float_dt:
				case double_dt:
					fprintf(outFile, "%s", arg->name);
					break;
				case object_dt:
					fprintf(outFile, "%s", arg->name);
					break;
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "%s", arg->name);
					break;
				case file_dt:
					fprintf(outFile, "%s", arg->name);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					;
			}
		} else { /* out_dir || inout_dir */
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
				case boolean_dt:
				case short_dt:
				case long_dt:
				case longlong_dt:
				case int_dt:
				case float_dt:
				case double_dt:
					fprintf(outFile, "&%s", arg->name);
					break;
				case object_dt:
					fprintf(outFile, "&%s", arg->name);
					break;
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "&%s", arg->name);
					break;
				case file_dt:
					fprintf(outFile, "&%s", arg->name);
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:
					;
			}
		}
		arg = arg->next_argument;
	}
	
	fprintf(outFile, ");\n");
	
	fprintf(outFile, "\n");

	is_first_arg = 1;
	arg = func->first_argument;
	while (arg != NULL) {
		i = j*3;

		if (arg->dir == out_dir || arg->dir == inout_dir) {
			switch (arg->type) {
				case char_dt:
				case wchar_dt:
				case boolean_dt:
				case short_dt:
				case long_dt:
				case longlong_dt:
				case int_dt:
				case float_dt:
				case double_dt:
				case object_dt:
					fprintf(outFile, "\t\t\t ofstream %s_ofs(%s_filename);\n", arg->name, arg->name);
					fprintf(outFile, "\t\t\t archive::text_oarchive %s_oa(%s_ofs);\n", arg->name, arg->name);
					fprintf(outFile, "\t\t\t %s_oa << %s;\n", arg->name, arg->name);
					break;
				case string_dt:
				case wstring_dt:
					fprintf(outFile, "\t\t\t ofstream %s_ofs(%s_filename);\n", arg->name, arg->name);
					fprintf(outFile, "\t\t\t archive::text_oarchive %s_oa(%s_ofs);\n", arg->name, arg->name);
					fprintf(outFile, "\t\t\t string %s_out_string (%s);\n", arg->name, arg->name);
					fprintf(outFile, "\t\t\t %s_oa << %s_out_string;\n", arg->name, arg->name);
					break;
				case file_dt:
					break;
				case void_dt:
				case any_dt:
				case null_dt:
				default:;
			}
		}

		fprintf(outFile, "\n");

		arg = arg->next_argument;
		j++;
	}

	arg = func->first_argument;
	while (arg != NULL) {
		switch (arg->type) {
			case char_dt:
			case wchar_dt:
			case boolean_dt:
			case short_dt:
			case long_dt:
			case longlong_dt:
			case int_dt:
			case float_dt:
			case double_dt:
				break;
			case file_dt:
				fprintf(outFile, "\t\t\t free(%s);\n", arg->name);
				break;
			case string_dt:
			case wstring_dt:
				fprintf(outFile, "\t\t\t free(%s);\n", arg->name);
				break;
			case void_dt:
		case any_dt:
			case null_dt:
			default:
				;
		}
		arg = arg->next_argument;
	}

	fprintf(outFile, "\t\t }\n");
	
	fprintf(outFile, "\t\t break;\n");
	
}	
			

void generate_body(void)
{
	function *current_function;
	
	generate_enum(includeFile, get_first_function());

	fprintf(stubsFile, "\n");

	fprintf(includeFile, "/* Functions to be implemented. We sugest that you create a file */\n");
	fprintf(includeFile, "/* with name '%s-functions.cc' and implement them there. */\n", get_filename_base());

	current_function = get_first_function();
	while (current_function != NULL) {
		generate_prototype(stubsFile, current_function);
		fprintf(stubsFile, "\n");
		fprintf(stubsFile, "{\n");
		generate_parameter_buffers(stubsFile, current_function);
		generate_parameter_marshalling(stubsFile, current_function);
		generate_execute_call(stubsFile, current_function);
		generate_constraints(current_function);
		fprintf(stubsFile, "}\n");
		fprintf(stubsFile, "\n");
		
		generate_worker_case(workerFile, current_function);
		
		generate_class_includes(includeFile, current_function);
		generate_prototype(includeFile, current_function);

		fprintf(includeFile, ";\n");

		current_function = current_function->next_function;
	}
}

